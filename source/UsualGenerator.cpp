/*************************************************************
  UsualGenerator.cpp - Copyright (C) 2016 by Dmitry Sultanov
 *************************************************************/

#include <MovesGenerator.h>
#include <MovesTable.h>
#include <xindex.h>

//////////////////////////////////////////////////////////////////////////

namespace NEngine
{

UsualGenerator::UsualGenerator(Board & board) :
  MovesGeneratorBase(board)
{
  hmove_.clear();
  killer_.clear();
}

void UsualGenerator::restart()
{
  if ( !numOfMoves_ )
    return;

  for (int i = 0; i < numOfMoves_; ++i)
    moves_[i].alreadyDone_ = 0;
}

int UsualGenerator::generate(const Move & hmove, const Move & killer)
{
  if ( numOfMoves_ > 0 )
    return numOfMoves_;

  hmove_  = hmove;
  killer_ = killer;
  numOfMoves_ = 0;

  const Figure::Color & color = board_.color_;
  const Figure::Color ocolor = Figure::otherColor(color);
  BitMask mask_all_inv = ~(board_.fmgr_.mask(Figure::ColorWhite) | board_.fmgr_.mask(Figure::ColorBlack));

  // pawns movements
  if ( board_.fmgr().pawn_mask(color) )
  {
    BitMask pw_mask = board_.fmgr().pawn_mask(color);
    for ( ; pw_mask; )
    {
      int pw_pos = clear_lsb(pw_mask);

      int y = Index(pw_pos).y();
      if ( (y == 1 && !color) || (y == 6 && color) ) // skip promotions, already generated by caps generator
        continue;

      const int8 * table = movesTable().pawn(color, pw_pos) + 2; // skip captures
      for (; *table >= 0 && !board_.getField(*table); ++table)
        add(numOfMoves_, pw_pos, *table, Figure::TypeNone, false);
    }
  }

  // knights movements
  if ( board_.fmgr().knight_mask(color) )
  {
    BitMask kn_mask = board_.fmgr().knight_mask(color);
    for ( ; kn_mask; )
    {
      int kn_pos = clear_lsb(kn_mask);
      BitMask kn_caps = movesTable().caps(Figure::TypeKnight, kn_pos) & mask_all_inv;

      for ( ; kn_caps; )
      {
        int to = clear_lsb(kn_caps);

        const Field & field = board_.getField(to);
        X_ASSERT( field, "try to generate capture" );

        add(numOfMoves_, kn_pos, to, Figure::TypeNone, false);
      }
    }
  }

  // bishops, rooks and queens movements
  for (int type = Figure::TypeBishop; type < Figure::TypeKing; ++type)
  {
    BitMask fg_mask = board_.fmgr().type_mask((Figure::Type)type, color);

    for ( ; fg_mask; )
    {
      int fg_pos = clear_lsb(fg_mask);

      const uint16 * table = movesTable().move(type-Figure::TypeBishop, fg_pos);

      for (; *table; ++table)
      {
        const int8 * packed = reinterpret_cast<const int8*>(table);
        int8 count = packed[0];
        int8 delta = packed[1];

        int8 p = fg_pos;
        for ( ; count; --count)
        {
          p += delta;

          const Field & field = board_.getField(p);
          if ( field )
            break;

          add(numOfMoves_, fg_pos, p, Figure::TypeNone, false);
        }
      }
    }
  }

  // kings movements
  {
    int ki_pos = board_.kingPos(color);
    BitMask ki_mask = movesTable().caps(Figure::TypeKing, ki_pos) & mask_all_inv;

    if ( ki_mask )
    {
      // short castle
      if ( board_.castling(board_.color_, 0) && !board_.getField(ki_pos+2) && !board_.getField(ki_pos+1) )
        add(numOfMoves_, ki_pos, ki_pos+2, Figure::TypeNone, false);

      // long castle
      if ( board_.castling(board_.color_, 1) && !board_.getField(ki_pos-2) && !board_.getField(ki_pos-1) && !board_.getField(ki_pos-3) )
        add(numOfMoves_, ki_pos, ki_pos-2, Figure::TypeNone, false);

      for ( ; ki_mask; )
      {
        int to = clear_lsb(ki_mask);

        const Field & field = board_.getField(to);
        X_ASSERT( field, "try to capture by king" );

        add(numOfMoves_, ki_pos, to, Figure::TypeNone, false);
      }
    }
  }

  moves_[numOfMoves_].clear();
  return numOfMoves_;
}

} // 
